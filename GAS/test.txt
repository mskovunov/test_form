/**
 * Обрабатывает GET-запросы для получения данных.
 * Используется для:
 * 1. getLast: Получение последнего показателя (для поля "Було").
 * 2. getPortStatus: Получение статуса порта зарядки из H1.
 * 3. history: Получение отфильтрованной истории показаний.
 */
function doGet(e) {
  const sheet = SpreadsheetApp.openById("1HgJDnd3ua_Z7OFU1nSEW1jaHVgiFzx_FBthYTnPMaxo")
                             .getSheetByName("Парковка");

  // Получение последнего значения (для поля "було")
  if (e.parameter.getLast) {
    return ContentService.createTextOutput(getLastValToUse());
  }

  // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
  // --- ИЗМЕНЕНИЕ 1: Получение статуса порта ---
  if (e.parameter.getPortStatus) {
    // Ячейка H1 хранит статус: 1 (занято) или 0 (доступно)
    
    // ИСПРАВЛЕНИЕ ЛОГИКИ: Приводим значение к строке для надежного сравнения,
    // чтобы исключить ошибку типа, если в H1 случайно записан текст "1" или "0".
    const statusValue = sheet.getRange("H1").getValue().toString();
    
    // Сравниваем со строкой "1"
    const statusText = (statusValue === "1") ? "busy" : "available"; 
    
    return ContentService.createTextOutput(statusText).setMimeType(ContentService.MimeType.TEXT);
  }
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  // --- ДОБАВЛЕНИЕ 5: Обработчик для страницы настроек ---
  if (e.parameter.getConfig) {
    return getConfigRecipients(); 
  }

  // История — HTML-таблица
  if (e.parameter.history) {
    
    // Определяем текущую дату, которая будет использоваться по умолчанию (текущий месяц)
    const now = new Date();
    let filterYear = now.getFullYear();
    let filterMonth = now.getMonth(); // Месяц в JS: 0 (Январь) - 11 (Декабрь)
    
    // monthParam будет выглядеть как 'YYYY-MM' (например, '2025-09')
    const monthParam = e.parameter.month;

    // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    // --- ИЗМЕНЕНИЕ 2: Упрощение логики фильтрации ---
    // Если параметр месяца передан, используем его для фильтра. Иначе - используем текущий месяц (default).
    if (monthParam && monthParam.length === 7 && monthParam.includes('-')) {
      const parts = monthParam.split('-');
      // Перезаписываем фильтр на выбранный месяц
      filterYear = parseInt(parts[0]);
      // Месяцы в JS начинаются с 0, поэтому отнимаем 1
      filterMonth = parseInt(parts[1]) - 1; 
    }
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


    // Читаем данные A2:E. 
    const data = sheet.getRange("A2:E" + sheet.getLastRow()).getValues();

    // Обработка строк
    const filtered = data
      .map(row => {
        const rawDate = row[0];
        const parsedDate = (rawDate instanceof Date) ? rawDate : new Date(rawDate);
        
        return {
          dateObj: parsedDate,
          // Формат даты без времени (dd.MM.yyyy)
          formattedDate: Utilities.formatDate(parsedDate, Session.getScriptTimeZone(), "dd.MM.yyyy"), 
          user: row[1],
          from: row[2],
          to: row[3],
          diff: row[4]
        };
      })
      .filter(row => {
        // Фильтрация всегда происходит по определенному месяцу (текущему или выбранному)
        return (
          row.dateObj.getFullYear() === filterYear &&
          row.dateObj.getMonth() === filterMonth
        );
      })
      .sort((a, b) => b.dateObj - a.dateObj); // Сортировка по убыванию даты (новые сверху)


    // Формируем HTML-таблицу
    let html = '<div id="history"><h3>Останні показники</h3><table><thead><tr><th>Дата</th><th>Користувач</th><th>Було</th><th>Стало</th><th>Різниця</th></tr></thead><tbody>';

    filtered.forEach(row => {
      // ИЗМЕНЕНИЕ 3: Применение toFixed(1) к полю diff для корректного отображения в таблице
      html += `<tr>
        <td>${row.formattedDate}</td>
        <td>${row.user}</td>
        <td>${(typeof row.from === 'number') ? row.from.toFixed(1) : row.from}</td>
        <td>${(typeof row.to === 'number') ? row.to.toFixed(1) : row.to}</td>
        <td>${(typeof row.diff === 'number') ? row.diff.toFixed(1) : row.diff}</td>
      </tr>`;
    });

    html += '</tbody></table></div>';

    return ContentService.createTextOutput(html).setMimeType(ContentService.MimeType.TEXT);
  }

  // По умолчанию
  return HtmlService.createHtmlOutput('Web App працює');
}

/**
 * Обрабатывает POST-запросы для записи данных в таблицу.
 * Используется для:
 * 1. Записи новых показаний.
 * 2. Обновления статуса порта.
 */
function doPost(e) {
  const sheet = SpreadsheetApp.openById("1HgJDnd3ua_Z7OFU1nSEW1jaHVgiFzx_FBthYTnPMaxo")
                             .getSheetByName("Парковка");

  // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
// --- ИЗМЕНЕНИЕ: ОБНОВЛЕНИЕ СТАТУСА КОНФИГА (ЧТЕНИЕ КОЛОНКИ) ---
  if (e.parameter.updateConfig === '1') {
    try {
      const rowNum = parseInt(e.parameter.row);
      const newStatus = e.parameter.status; // '1' или '0'
      // НОВОЕ: Считываем номер колонки, которую нужно обновить (5 или 6)
      const targetColumn = parseInt(e.parameter.column); 
      
      // Проверка на корректность входных данных
      if (isNaN(rowNum) || rowNum < 2 || isNaN(targetColumn) || targetColumn < 5 || targetColumn > 6) {
          return ContentService.createTextOutput("Error: Invalid input parameters").setMimeType(ContentService.MimeType.TEXT);
      }
      
      const configSheet = SpreadsheetApp.openById("1HgJDnd3ua_Z7OFU1nSEW1jaHVgiFzx_FBthYTnPMaxo")
                                       .getSheetByName("Config");
      
      // Используем targetColumn для записи в колонку E (5) или F (6)
      configSheet.getRange(rowNum, targetColumn).setValue(parseInt(newStatus)); 
      
      // Возвращаем успешный ответ
      return ContentService.createTextOutput("Success").setMimeType(ContentService.MimeType.TEXT);
      
    } catch (error) {
      Logger.log("Error updating config status: " + error.toString());
      return ContentService.createTextOutput("Error: Could not update config status").setMimeType(ContentService.MimeType.TEXT);
    }
  }
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  

  // Если пришёл параметр для статуса порта — обновляем ячейку H1
  if (e.parameter.portStatus !== undefined) {
    const value = e.parameter.portStatus === "1" ? 1 : 0;
    sheet.getRange("H1").setValue(value);
    
    // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    // --- ИЗМЕНЕНИЕ 4: ДОБАВЛЕНИЕ ЛОГИКИ ОТПРАВКИ E-MAIL ---
    const recipient = getRecipientList(); // Динамическое получение списка получателей
    const statusLabel = value === 1 ? "ЗАЙНЯТИЙ" : "ДОСТУПНИЙ";
    
    // Проверка, что список получателей не пуст
    if (recipient) {
        try {
            // NOTE: GmailApp требует авторизации при первом использовании
            GmailApp.sendEmail(
                recipient, // Получатель теперь может быть строкой из нескольких адресов через запятую
                `СТАТУС : ${statusLabel}`,
                `Порт зарядки на парковці був успішно змінено на : ${statusLabel}.`
            );
        } catch (error) {
            // Логирование ошибки отправки почты (не влияет на работу сайта)
            Logger.log("Помилка відправки пошти: " + error.toString());
        }
    }
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    return ContentService.createTextOutput("Port status updated");
  }
  
  const now = new Date();
  const formattedDate = Utilities.formatDate(now, Session.getScriptTimeZone(), "dd.MM.yyyy HH:mm:ss");
  const lastRow = sheet.getLastRow();
  const CurRow = lastRow + 1;
  const reading = e.parameter.reading.replace('.', ',');
  const valastRow = sheet.getRange('D' + lastRow).getValue();
  let valToUse = valastRow;

  if (!valastRow && lastRow > 1) {
    valToUse = sheet.getRange('D' + (lastRow - 1)).getValue();
  }

  sheet.appendRow([
    formattedDate,
    e.parameter.name || '', 
    valToUse,
    reading || '',
    '=D' + CurRow + '-C' + CurRow,
    '9',
    '=E' + CurRow + '*F' + CurRow
  ]);


  // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
  // --- ИЗМЕНЕНИЕ 4: Замена HTML-редиректа на чистый текстовый ответ ---
  return ContentService.createTextOutput("Success").setMimeType(ContentService.MimeType.TEXT);
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
}

/**
 * Вспомогательная функция для получения списка получателей из таблицы.
 * (Считывает адреса электронной почты из листа "Config", колонка D, где в колонке E стоит 1).
 */
function getRecipientList() {
  // ИЗМЕНЕНИЕ: Получаем лист "Config"
  const configSheet = SpreadsheetApp.openById("1HgJDnd3ua_Z7OFU1nSEW1jaHVgiFzx_FBthYTnPMaxo")
                             .getSheetByName("Config"); 
  
  if (!configSheet) {
    Logger.log("Ошибка: Лист Config не найден.");
    return ''; // Возвращаем пустую строку, чтобы избежать сбоя
  }

  // --- ИЗМЕНЕНИЕ ЛОГИКИ: Читаем колонки D и E ---
  const lastRow = configSheet.getLastRow();
  // Читаем диапазон D2:E<Последняя строка>. 
  // Столбец D - Адреса, Столбец E - Признак (1)
  const dataRange = configSheet.getRange("D2:E" + lastRow);
  const data = dataRange.getValues();
  
  const emails = [];
  
  // Перебираем все строки данных
  for (let i = 0; i < data.length; i++) {
    const row = data[i];
    const email = row[0]; // Элемент в колонке D (индекс 0 в прочитанном массиве)
    const flag = row[1];  // Элемент в колонке E (индекс 1 в прочитанном массиве)
    
    // ИСПРАВЛЕНИЕ ЛОГИКИ: Приводим признак к строке и сравниваем со строкой "1"
    const flagString = String(flag).trim(); 

    // Проверка: Признак должен быть строго "1" И адрес должен быть не пустым
    if ( flagString === '1' && email && String(email).trim() !== '') {
        emails.push(String(email).trim());
    }
    // Если флаг пустой (т.е. "" или null/undefined), он не пройдет строгую проверку '1'
  }

  // Проверяем, что есть адреса
  if (emails.length === 0) {
    Logger.log("В листе Config не найдено активных получателей с признаком '1'.");
    return '';
  }
    
  return emails.join(', '); // Возвращаем строку, разделенную запятыми
}

// --- ДОБАВЛЕНИЕ 5: Функция для страницы настроек (JSON) ---
/**
 * Считывает и возвращает список получателей из листа "Config" в формате JSON.
 * Используется страницей settings.html.
 */
function getConfigRecipients() {
  const configSheet = SpreadsheetApp.openById("1HgJDnd3ua_Z7OFU1nSEW1jaHVgiFzx_FBthYTnPMaxo")
                             .getSheetByName("Config"); 
  
  if (!configSheet) {
    return ContentService.createTextOutput(JSON.stringify([])).setMimeType(ContentService.MimeType.JSON);
  }
  
  const lastRow = configSheet.getLastRow();
  // Читаем диапазон D2:E<Последняя строка>. 
  const dataRange = configSheet.getRange("B2:F" + lastRow);
  const data = dataRange.getValues();
  
  const results = [];
  
  for (let i = 0; i < data.length; i++) {
    const row = data[i];
    const user_a= row[0]; 
    const email = row[2]; 
    const flag = row[3];  // Колонка D (индекс 4)
    const flagP = row[4]; 
    
    // Добавляем все строки, чтобы пользователь мог видеть даже неактивные адреса
    results.push({
      user_a: String(user_a || '').trim(), 
      email: String(email || '').trim(), 
      flag: String(flag || '').trim(),
      flagP: String(flagP || '').trim() 
    });
  }
  
  return ContentService.createTextOutput(JSON.stringify(results))
                       .setMimeType(ContentService.MimeType.JSON);
}


/**
 * Вспомогательная функция для получения последнего значения из столбца D.
 */
function getLastValToUse() {
  const sheet = SpreadsheetApp.openById("1HgJDnd3ua_Z7OFU1nSEW1jaHVgiFzx_FBthYTnPMaxo")
                              .getSheetByName("Парковка");
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return '';

  let valastRow = sheet.getRange('D' + lastRow).getValue();
  if (!valastRow && lastRow > 1) {
    valastRow = sheet.getRange('D' + (lastRow - 1)).getValue();
  }
  return valastRow || '';
}
